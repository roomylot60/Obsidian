# MySQL Replication

## 1. 전체 구조 및 목표

- 구성

  - Source(=Primary) MySQL: 실제 쓰기/갱신이 일어나는 서버
  - Replica(=Secondary) MySQL: 읽기 전용, Source 변경 사항을 실시간 반영

- 연결 방식

  - Replica 쪽 mysqld 프로세스가 클라이언트처럼 Source에 TCP로 접속
  - Source의 binlog 이벤트를 읽어와 relay log에 적재 → 실제 데이터 적용

## 2. Source(MySQL) 설정 – binlog / server-id 활성화

- Source 서버에서 바이너리 로그(binlog) 및 고유 server-id 설정

### 2-1. 설정 파일 예시 (Source)

```ini
# ./mysql/conf.d/source.cnf
[mysqld]
server-id               = 1
log_bin                 = binlog
binlog_format           = ROW
# 필요 시 특정 DB만 복제
# binlog_do_db         = sync_test

# 외부 접속 허용 (도커/서버 상황에 맞게)
bind-address            = 0.0.0.0

default-time-zone       = '+09:00'
```

## 3. Replica(MySQL) 설정 – server-id / relay log / read_only

- Replica 서버에 고유 server-id 적용

### 3-1. 설정 파일 (Replica)

```ini
# ./mysql/conf.d/replica.cnf
[mysqld]
server-id        = 2
relay_log        = relay-bin
read_only        = 1
super_read_only  = 1
default-time-zone = '+09:00'

# 필요하면 특정 DB만 복제
# replicate_do_db = sync_test
```

- `server-id=2` : Source와 서버 ID가 달라야 복제가 동작
- `relay_log` : Source에서 받은 binlog 이벤트를 저장하는 파일
- `read_only=1`, `super_read_only=1` :
  - 일반 계정/루트 계정 모두 직접 쓰기 금지, 오직 Replication 스레드만 쓰기 가능
  - 이후 ALTER USER, INSERT 등을 Replica에서 실행할 때 실패하는 현상이 발생함

## 4. Source에서 Replication 전용 계정 생성

- Source MySQL에 접속해서 replication 전용 사용자 생성 (예: 사용자명 repl, 비밀번호 replpass)

```sql
-- Source 서버에서 실행
CREATE USER 'repl'@'%' IDENTIFIED BY 'replpass';

GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'repl'@'%';

FLUSH PRIVILEGES;
```

- Replica가 Source에 접속할 때 해당 계정을 사용.
- 실제 `SHOW REPLICA STATUS\G` 결과에서 아래처럼 사용:

```ini
Source_Host: 192.168.0.64
Source_Port: 23306
Source_User: repl
```

## 5. Source에서 현재 binlog 위치 확인

- 초기 동기화 및 `CHANGE REPLICATION SOURCE TO` 설정:
  - Source에서 현재 바이너리 로그 파일명 & 위치를 확인

```sql
-- Source 서버에서 실행
SHOW MASTER STATUS;
-- 또는 MySQL 8에서도 여전히 사용 가능

----------------------------------------------

-- 예상 결과
+------------------+----------+--------------+------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+------------------+----------+--------------+------------------+
| binlog.000004    |     1170 | sync_test    |                  |
+------------------+----------+--------------+------------------+
```

- Replica에서 나중에 `SHOW REPLICA STATUS\G` 했을 때:
  - `Source_Log_File: binlog.000004`, `Read_Source_Log_Pos: 1170`으로 나온 내용과 연동

## 6. 초기 데이터 동기화 (mysqldump → Replica import)

- Replication은 **특정 시점의 스냅샷 + 그 이후 변경 binlog** 구조
- 먼저 Source의 데이터를 Dump 떠서 Replica에 적용 작업을 진행

### 6-1. Source에서 전체/특정 DB 덤프 생성

```bash
# Source 컨테이너에서 실행 (예시)
docker exec -i sync-test-mysql-source \
  mysqldump -uroot -p --all-databases \
  --single-transaction --master-data=2 \
  > ./alldb_sync_test.sql
```

### 6-2. Replica에 덤프 파일 Import

- 발생한 문제:

  - Replica에 `read_only=1`, `super_read_only=1`가 켜진 상태에서
    `ALTER USER 'root'@'localhost' IDENTIFIED WITH ...`
  - 덤프 import 시도해서 --super-read-only 때문에 쓰기 불가 에러가 발생

- 정상적인 절차

  - 초기 데이터 import 시, 일시적으로 super_read_only를 off
  - Replication 설정 전 단계에서 import 먼저 수행
  - import 완료 후에 read_only, super_read_only를 on

예: super_read_only 잠시 해제 후 import

```sql
-- Replica 서버에서 (root로)
SET GLOBAL super_read_only = OFF;
SET GLOBAL read_only = OFF;
```

호스트에서 import:

```bash
# TTY 에러를 피하려면 -t 옵션을 빼고 -i만 사용하는 것이 안전
docker exec -i sync-test-mysql-replica \
  mysql -uroot -prootpass < ./alldb_sync_test.sql
```

import 이후 다시 읽기 전용으로 전환:

```sql
SET GLOBAL read_only = ON;
SET GLOBAL super_read_only = ON;
```

## 7. Replica에서 Replication 연결 설정

- Replica에서 어느 Source에, 어떤 계정으로, 어느 binlog 위치부터 읽을지를 설정

### 7-1. CHANGE REPLICATION SOURCE TO

- MySQL 8 버전 기준으로 `MASTER` 대신 `SOURCE` 명령을 사용

```sql
-- Replica 서버에서 실행
STOP REPLICA;

CHANGE REPLICATION SOURCE TO
  SOURCE_HOST = '192.168.0.64',
  SOURCE_PORT = 23306,
  SOURCE_USER = 'repl',
  SOURCE_PASSWORD = 'replpass',
  SOURCE_LOG_FILE = 'binlog.000004', -- 5번에서 확인한 binlog 파일
  SOURCE_LOG_POS  = 1170, -- binlog 파일 위치
  GET_SOURCE_PUBLIC_KEY = 1;  -- 필요 시
```

## 8. Replication 시작 및 상태 확인

### 8-1. 복제 시작

```sql
START REPLICA;
```

### 8-2. 상태 확인

```sql
SHOW REPLICA STATUS\G

------------------------------

-- 예상 결과
Replica_IO_State: Waiting for source to send event
Source_Host: 192.168.0.64
Source_User: repl
Source_Port: 23306
Source_Log_File: binlog.000004
Read_Source_Log_Pos: 1170
...
Seconds_Behind_Source: 0  (정상일 때)
Last_IO_Error:           (비어 있으면 정상)
Last_SQL_Error:          (비어 있으면 정상)

```

- `Replica_IO_State: Waiting for source to send event`: Source와 연결되어 이벤트를 잘 기다리고 있는 상태
- `Seconds_Behind_Source` 값이 NULL이 아니고 숫자로 유지되면 일반적으로 정상 동작

## 9. 에러 로그 / 일반 로그 확인

- `error.log`의 위치는 기본적으로 컨테이너 내부에 위치
- 예시 위치 (배포판에 따라 다름):
  - `/var/log/mysql/error.log`
  - `/var/log/mysqld.log`
