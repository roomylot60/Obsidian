<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>1&period; &#xbaa8;&#xb378;&#xb9c1;</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h2 id="1-모델링">1. 모델링</h2>
<h3 id="조사한-모델">조사한 모델</h3>
<ul>
<li>여러 알고리즘을 사용한 분류 알고리즘 활용</li>
<li>예시 : Gaussian Mixture Model</li>
</ul>
<pre><code class="language-python"><span class="hljs-comment"># GMM 적용</span>
<span class="hljs-keyword">from</span> sklearn.mixture <span class="hljs-keyword">import</span> GaussianMixture
data = df.values.tolist()
<span class="hljs-comment"># n_components로 미리 군집 개수 설정</span>
gmm = GaussianMixture(n_components=<span class="hljs-number">10</span>, n_init=<span class="hljs-number">3</span>, random_state=<span class="hljs-number">0</span>).fit(data)
<span class="hljs-comment"># n_init : 모델 반복 횟수 -&gt; 파라미터를 무작위로 선정하여 수렴할 때까지 학습</span>
gmm_labels = gmm.predict(data)
<span class="hljs-comment"># GMM 후 클러스터링 레이블을 따로 설정</span>
df[<span class="hljs-string">&#x27;gmm_cluster&#x27;</span>] = gmm_labels
</code></pre>
<pre><code class="language-powershell"><span class="hljs-number">2</span>    <span class="hljs-number">80</span>
<span class="hljs-number">9</span>    <span class="hljs-number">54</span>
<span class="hljs-number">7</span>    <span class="hljs-number">53</span>
<span class="hljs-number">4</span>    <span class="hljs-number">50</span>
<span class="hljs-number">1</span>    <span class="hljs-number">39</span>
<span class="hljs-number">3</span>    <span class="hljs-number">35</span>
<span class="hljs-number">8</span>    <span class="hljs-number">33</span>
<span class="hljs-number">6</span>    <span class="hljs-number">32</span>
<span class="hljs-number">0</span>    <span class="hljs-number">27</span>
<span class="hljs-number">5</span>    <span class="hljs-number">23</span>
Name: gmm_cluster, dtype: int64
</code></pre>
<ul>
<li>모델 성능 지표로 실루엣 계수를 활용</li>
</ul>
<pre><code class="language-python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> silhouette_score, silhouette_samples
score_samples = silhouette_samples(data, df[<span class="hljs-string">&#x27;gmm_cluster&#x27;</span>])
df[<span class="hljs-string">&#x27;silhouette_coeff&#x27;</span>]=score_samples
average_score = silhouette_score(data, df[<span class="hljs-string">&#x27;gmm_cluster&#x27;</span>])
<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Silhouette Analysis Score:{0:.3f}&#x27;</span>.<span class="hljs-built_in">format</span>(average_score))
</code></pre>
<pre><code class="language-powershell">Silhouette Analysis Score:<span class="hljs-number">0.133</span>
</code></pre>
<ul>
<li>선정 모델 : <strong>K-means 클러스터링</strong></li>
</ul>
<pre><code class="language-python"><span class="hljs-comment"># 1차 클러스터링</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">first_clustering</span>(<span class="hljs-params">df</span>):
    <span class="hljs-keyword">global</span> tmp_df
    basic_pca = PCA(n_components=<span class="hljs-number">2</span>, random_state=<span class="hljs-number">0</span>)
    basic_pca_transformed = basic_pca.fit_transform(df)

    <span class="hljs-comment"># density_data = minmax_norm(density_data)</span>
    <span class="hljs-comment"># 1차 군집화 : 4개의 집단으로 구성</span>
    first_kmeans = KMeans(n_clusters=<span class="hljs-number">4</span>, init=<span class="hljs-string">&#x27;k-means++&#x27;</span>, max_iter=<span class="hljs-number">300</span>, random_state=<span class="hljs-number">0</span>)
    first_kmeans.fit(basic_pca_transformed)

    basic_df = tmp_df.copy()
    basic_df[<span class="hljs-string">&#x27;km_cluster&#x27;</span>] = first_kmeans.labels_

    basic_df[<span class="hljs-string">&#x27;pca_x&#x27;</span>] = basic_pca_transformed[:, <span class="hljs-number">0</span>]
    basic_df[<span class="hljs-string">&#x27;pca_y&#x27;</span>] = basic_pca_transformed[:, <span class="hljs-number">1</span>]

    <span class="hljs-keyword">return</span> basic_df, first_kmeans, basic_pca

<span class="hljs-comment"># 2차 클러스터링</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">second_clustering</span>(<span class="hljs-params">basic_df, df, user_first</span>):
    <span class="hljs-comment"># 각 군집에서 나눌 집단의 수 리스트 작성</span>
    cluster_num = [<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>]
    second_cluster = basic_df[basic_df[<span class="hljs-string">&#x27;km_cluster&#x27;</span>] == user_first]
    cluster_data = df.loc[second_cluster.index.values]
    second_pca = PCA(n_components=<span class="hljs-number">2</span>)
    second_pca_transformed = second_pca.fit_transform(cluster_data)
    second_kmeans = KMeans(n_clusters=cluster_num[user_first], init=<span class="hljs-string">&#x27;k-means++&#x27;</span>, max_iter=<span class="hljs-number">400</span>, random_state=<span class="hljs-number">0</span>)
    second_kmeans.fit(second_pca_transformed)

    cluster_tmp = second_cluster.copy()
    cluster_tmp[<span class="hljs-string">&#x27;km_cluster&#x27;</span>] = second_kmeans.labels_
    <span class="hljs-keyword">return</span> second_kmeans, second_pca, cluster_tmp
</code></pre>
<pre><code class="language-python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> silhouette_samples, silhouette_score
silhouette_score(basic_pca_transformed, basic_df[<span class="hljs-string">&#x27;km_cluster&#x27;</span>])
</code></pre>
<pre><code class="language-powershell"><span class="hljs-number">0.4494277856248356</span>
</code></pre>
<h2 id="2-내부-함수-작성">2. 내부 함수 작성</h2>
<h3 id="추천-시스템-구조">추천 시스템 구조</h3>
<ol>
<li>거주 선택과 관련된 요소 6가지에 대해 1차 k-means cluster를 사용하여 분류</li>
<li>주 타켓층(MZ 세대)들이 거주지 선택에 있어서 선호하는 요소들을 사용하여 2차 분류</li>
<li>분류된 군집에 대해 사용자 입력값을 사용하여 분류 모델에 적용하고, 얻은 값과 유사한 지역을 추천</li>
</ol>
<h3 id="작성-코드-예시">작성 코드 예시</h3>
<h4 id="함수-구성-전">함수 구성 전</h4>
<p><img src="file:///d:\Programming\Obsidian\Obsidian\Attatched\tmp_1.png" alt="">
<img src="file:///d:\Programming\Obsidian\Obsidian\Attatched\tmp_2.png" alt=""></p>
<h4 id="함수-구성-후">함수 구성 후</h4>
<ul>
<li>1차 분류를 위한 features를 다루는 함수</li>
<li>'교통', '교육', '육아', '치안', '건강', '편의' 6가지 요소를 활용하였으며, 각 요소에 속하는 feature에 대해 가중치를 부여하고 통합</li>
</ul>
<pre><code class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">assembling_features</span>(<span class="hljs-params">df</span>):
    <span class="hljs-keyword">global</span> tmp_df
    <span class="hljs-comment"># 피쳐합</span>
    tmp_df = df.copy()
    <span class="hljs-comment"># 교통</span>
    tmp_df[<span class="hljs-string">&#x27;교통&#x27;</span>] = tmp_df[<span class="hljs-string">&#x27;SUBWAY_NUM&#x27;</span>] + <span class="hljs-number">0.93</span> * tmp_df[<span class="hljs-string">&#x27;BUS_CNT&#x27;</span>] + <span class="hljs-number">0.06</span> * tmp_df[<span class="hljs-string">&#x27;BIKE_NUM&#x27;</span>]
    tmp_df = tmp_df.drop([<span class="hljs-string">&#x27;SUBWAY_NUM&#x27;</span>, <span class="hljs-string">&#x27;BUS_CNT&#x27;</span>, <span class="hljs-string">&#x27;BIKE_NUM&#x27;</span>], axis=<span class="hljs-number">1</span>)

    <span class="hljs-comment"># 교육</span>
    tmp_df[<span class="hljs-string">&#x27;교육&#x27;</span>] = (<span class="hljs-number">0.07</span>) * tmp_df[<span class="hljs-string">&#x27;MID_SCH_NUM&#x27;</span>] + (<span class="hljs-number">0.03</span>) * tmp_df[<span class="hljs-string">&#x27;HIGH_SCH_NUM&#x27;</span>] + tmp_df[<span class="hljs-string">&#x27;ACADEMY_NUM&#x27;</span>] * (<span class="hljs-number">0.7</span>) + (
        <span class="hljs-number">0.9</span>) * tmp_df[<span class="hljs-string">&#x27;ELE_SCH_NUM&#x27;</span>]
    tmp_df = tmp_df.drop([<span class="hljs-string">&#x27;MID_SCH_NUM&#x27;</span>, <span class="hljs-string">&#x27;HIGH_SCH_NUM&#x27;</span>, <span class="hljs-string">&#x27;ACADEMY_NUM&#x27;</span>, <span class="hljs-string">&#x27;ELE_SCH_NUM&#x27;</span>], axis=<span class="hljs-number">1</span>)

    <span class="hljs-comment"># 육아</span>
    tmp_df[<span class="hljs-string">&#x27;육아&#x27;</span>] = tmp_df[<span class="hljs-string">&#x27;CHILD_MED_NUM&#x27;</span>] + tmp_df[<span class="hljs-string">&#x27;KINDER_NUM&#x27;</span>]
    tmp_df = tmp_df.drop([<span class="hljs-string">&#x27;CHILD_MED_NUM&#x27;</span>, <span class="hljs-string">&#x27;KINDER_NUM&#x27;</span>], axis=<span class="hljs-number">1</span>)

    <span class="hljs-comment"># 치안</span>
    tmp_df[<span class="hljs-string">&#x27;치안&#x27;</span>] = tmp_df[<span class="hljs-string">&#x27;POLICE_NUM&#x27;</span>] + tmp_df[<span class="hljs-string">&#x27;CCTV_NUM&#x27;</span>] + tmp_df[<span class="hljs-string">&#x27;FIRE_NUM&#x27;</span>]
    tmp_df = tmp_df.drop([<span class="hljs-string">&#x27;POLICE_NUM&#x27;</span>, <span class="hljs-string">&#x27;CCTV_NUM&#x27;</span>, <span class="hljs-string">&#x27;FIRE_NUM&#x27;</span>], axis=<span class="hljs-number">1</span>)

    <span class="hljs-comment"># 건강</span>
    tmp_df[<span class="hljs-string">&#x27;건강&#x27;</span>] = (<span class="hljs-number">0.94</span>) * tmp_df[<span class="hljs-string">&#x27;HOSPITAL_NUM&#x27;</span>] + tmp_df[<span class="hljs-string">&#x27;PHARM_NUM&#x27;</span>]
    tmp_df = tmp_df.drop([<span class="hljs-string">&#x27;HOSPITAL_NUM&#x27;</span>, <span class="hljs-string">&#x27;PHARM_NUM&#x27;</span>], axis=<span class="hljs-number">1</span>)

    <span class="hljs-comment"># 편의시설</span>
    tmp_df[<span class="hljs-string">&#x27;편의시설&#x27;</span>] = <span class="hljs-number">0.04</span> * tmp_df[<span class="hljs-string">&#x27;DPTM_NUM&#x27;</span>] + <span class="hljs-number">0.44</span> * tmp_df[<span class="hljs-string">&#x27;CON_NUM&#x27;</span>] + <span class="hljs-number">0.25</span> * tmp_df[<span class="hljs-string">&#x27;CAFE_NUM&#x27;</span>] + <span class="hljs-number">0.27</span> * tmp_df[
        <span class="hljs-string">&#x27;RETAIL_NUM&#x27;</span>]
    tmp_df = tmp_df.drop([<span class="hljs-string">&#x27;DPTM_NUM&#x27;</span>, <span class="hljs-string">&#x27;CON_NUM&#x27;</span>, <span class="hljs-string">&#x27;CAFE_NUM&#x27;</span>, <span class="hljs-string">&#x27;RETAIL_NUM&#x27;</span>], axis=<span class="hljs-number">1</span>)

    tmp_df.set_index(<span class="hljs-string">&#x27;DONG_CODE&#x27;</span>, inplace=<span class="hljs-literal">True</span>)

    <span class="hljs-keyword">return</span> tmp_df

</code></pre>
<ol>
<li>교통 : 지하철, 버스, 자전거(따릉이) 정거장 수와 관련된 가중치를 계산하여 적용 및 통합하여 하나의 feature로 재구성</li>
<li>교육 : 초등학교, 중학교, 고등학교, 학원의 수에 대한 가중치를 부여
<ul>
<li>타겟층인 MZ 세대는 신혼 부부에 속하는 연령층도 포함되기에 학군에 대한 부분이 고려됨</li>
</ul>
</li>
<li>육아 : 소아과, 어린이집에 대한 부분을 포함</li>
<li>치안 : 경찰, 소방서 및 CCTV 설치 수 등을 고려</li>
<li>건강 : 병원, 약국의 수</li>
<li>편의 시설 : 백화점, 편의점, 카페, 시장 수 대해 각각의 가중치를 부여</li>
</ol>
<pre><code class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">preprocessing_df</span>():
    area_df = merge_area_data()
    assem_df = assembling_features(area_df)

    tmp_data = assem_df.iloc[:, <span class="hljs-number">3</span>:]
    df = tmp_data.div(assem_df[<span class="hljs-string">&#x27;AREA&#x27;</span>], axis=<span class="hljs-number">0</span>)

    max_lim_log_list = [<span class="hljs-string">&quot;교통&quot;</span>, <span class="hljs-string">&quot;치안&quot;</span>, <span class="hljs-string">&quot;교육&quot;</span>, <span class="hljs-string">&quot;COLIVING_NUM&quot;</span>, <span class="hljs-string">&quot;STARBUCKS_NUM&quot;</span>, <span class="hljs-string">&quot;MC_NUM&quot;</span>, <span class="hljs-string">&quot;NOISE_VIBRATION_NUM&quot;</span>, <span class="hljs-string">&quot;VEGAN_CNT&quot;</span>]

    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> max_lim_log_list:
        quan = df[f].quantile(<span class="hljs-number">0.95</span>)
        df[f] = np.where(df[f] &gt; quan, quan, df[f])
        df[f] = np.log1p(df[f])

    max_lim_list = [<span class="hljs-string">&quot;LEISURE_NUM&quot;</span>, <span class="hljs-string">&quot;GOLF_NUM&quot;</span>, <span class="hljs-string">&quot;건강&quot;</span>, <span class="hljs-string">&quot;편의시설&quot;</span>]
    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> max_lim_list:
        quan = df[f].quantile(<span class="hljs-number">0.95</span>)
        df[f] = np.where(df[f] &gt; quan, quan, df[f])

    ro_df = robust_scaling(df)
    ro_df = ro_df[[<span class="hljs-string">&#x27;교통&#x27;</span>, <span class="hljs-string">&#x27;치안&#x27;</span>, <span class="hljs-string">&#x27;건강&#x27;</span>, <span class="hljs-string">&#x27;편의시설&#x27;</span>, <span class="hljs-string">&#x27;교육&#x27;</span>,
             <span class="hljs-string">&#x27;육아&#x27;</span>, <span class="hljs-string">&#x27;MZ_POP_CNT&#x27;</span>, <span class="hljs-string">&#x27;COLIVING_NUM&#x27;</span>, <span class="hljs-string">&#x27;VEGAN_CNT&#x27;</span>, <span class="hljs-string">&#x27;KIDS_NUM&#x27;</span>,
             <span class="hljs-string">&#x27;PARK_NUM&#x27;</span>, <span class="hljs-string">&#x27;STARBUCKS_NUM&#x27;</span>, <span class="hljs-string">&#x27;MC_NUM&#x27;</span>, <span class="hljs-string">&#x27;NOISE_VIBRATION_NUM&#x27;</span>,
             <span class="hljs-string">&#x27;SAFE_DLVR_NUM&#x27;</span>, <span class="hljs-string">&#x27;LEISURE_NUM&#x27;</span>, <span class="hljs-string">&#x27;GYM_NUM&#x27;</span>, <span class="hljs-string">&#x27;GOLF_NUM&#x27;</span>, <span class="hljs-string">&#x27;CAR_SHR_NUM&#x27;</span>,
             <span class="hljs-string">&#x27;ANI_HSPT_NUM&#x27;</span>]]

    <span class="hljs-keyword">return</span> ro_df
</code></pre>
<ul>
<li>서울시 행정구 별 면적에 대한 데이터를 화룡</li>
<li>면적 대비 시설의 개수를 사용할 feature를 선정</li>
<li>개별 수치가 매우 큰 데이터에는 log scale을 적용</li>
<li>적용한 수치의 이상치 및 의미가 없는 값을 제거하기 위해 quantile을 적용</li>
<li>최종 사용할 데이터를 DF 형식으로 리턴</li>
</ul>
<h2 id="3-가중치-로직-개발">3. 가중치 로직 개발</h2>
<ul>
<li>시스템 구조 상 2차에 걸쳐 군집화를 실시하므로, 각 군집화에서 사용되는 feature들에 대해 가중치 부여를 분리
<img src="file:///d:\Programming\Obsidian\Obsidian\Attatched\Pasted%20image%2020240318034056.png" alt=""></li>
<li>1차 분류에 사용되는 feature들과  2차 분류에 사용되는 feature 간의 연관성을 고려하여 가중치를 부여
<img src="file:///d:\Programming\Obsidian\Obsidian\Attatched\Pasted%20image%2020240318033158.png" alt=""></li>
<li>2차 분류 가중치에 대한 근거로 크롤링 데이터를 활용
<img src="file:///d:\Programming\Obsidian\Obsidian\Attatched\Pasted%20image%2020240318035011.png" alt=""></li>
</ul>
<h4 id="가중치-함수--사용자-입력값과-내부-가중치-결합">가중치 함수 : 사용자 입력값과 내부 가중치 결합</h4>
<pre><code class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">weighting</span>(<span class="hljs-params">user_df, df, select, user_name</span>):
    weight_df = pd.read_excel(<span class="hljs-string">&#x27;recommend_app/data/1107_가중치.xlsx&#x27;</span>)
    weight_df.rename(columns={<span class="hljs-string">&#x27;Unnamed: 0&#x27;</span>: <span class="hljs-string">&#x27;분류&#x27;</span>}, inplace=<span class="hljs-literal">True</span>)
    weight_df.fillna(<span class="hljs-number">0</span>, inplace=<span class="hljs-literal">True</span>)
    weight_df.set_index(<span class="hljs-string">&#x27;분류&#x27;</span>, inplace=<span class="hljs-literal">True</span>)

    values = user_df.loc[user_name].values
    weight = weight_df[weight_df.columns].values
    w = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(weight)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(weight)):
        <span class="hljs-keyword">if</span>(select[i] == <span class="hljs-number">1</span>):
            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(weight[i])):
                w[i] += weight[i][k]

    weighted_user_data = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(values)):
        weighted_data = values[i] * w[i]
        weighted_user_data.append(weighted_data)
    weighted_user_df = pd.DataFrame(weighted_user_data,index=df.columns,columns=[<span class="hljs-string">&#x27;user&#x27;</span>]).T
    <span class="hljs-keyword">return</span> weighted_user_df
</code></pre>
<ul>
<li><code>.xlsx</code> 파일로 작성한 가중치를 데이터 프레임 형태로 입력 받아 재구성</li>
<li><code>user_df</code> : 사용자가 입력한 수치</li>
<li><code>weight_df</code> : 내부 가중치</li>
<li><code>weighted_user_df</code> : 추천 시스템에서 사용할 최종 가중치</li>
</ul>

            
            
        </body>
        </html>